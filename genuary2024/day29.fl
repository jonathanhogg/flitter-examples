-- Genuary day 29: Signed Distance Functions
--
-- (Also Genuary day 12: Lava lamp; and Genuary day 30: Shaders)
--
-- This sketch makes use of Flitter's support for custom shaders in 3D scenes.
--
-- A simple physics system simulates a bunch of blobs with random radii,
-- starting positions and starting temperatures. Blobs hotter than 1500Â°K rise
-- and cooler blobs sink. Blobs gain or lose heat depending on whether they are
-- nearer to the bottom or top of the sphere. The blobs have an adhesion force
-- that make them tend to loosely clump together, some slight Brownian motion
-- randomness, buoyancy and drag complete the simulation. The buoyancy is
-- controlled by keeping the mass of the particles the same and varying the
-- radius according to the temperature so that they change density. An anchored
-- central particle with a large radius forms an obstacle that the other
-- particles must move around.
--
-- A group is constructed containing oversized spheres around each of the blobs
-- and this is rendered with a custom SDF shader. The shader takes the
-- positions, radii and colours of the blobs as input and raymarches through
-- the shaded fragment in the opposite direction to the camera. If the
-- raymarcher gets a hit with the SDF then it returns the calculated colour at
-- that point using the same PBR algorithm as the normal Flitter one, and sets
-- the fragment depth to the actual depth of the SDF surface. Any ray that
-- doesn't hit an SDF surface is discarded.
--
-- To limit the amount of calculation that has to be done, we do an initial
-- pass rendering all faces of the oversize spheres from the same camera angle
-- with a different custom shader that records the minimum and maximum depth.
-- We pass this texture into the SDF shader. It can use this to only raymarch
-- each ray once, beginning at the near surface of the render volume and
-- stopping at the far side.
--
-- The end result is that the SDF scene is rendered within the containing
-- spheres in a depth-accurate way. We demonstrate the latter by rendering a
-- green sphere in the same scene - representing the central anchored obstacle
-- in the physics system - using the normal lighting shader. The depth buffer
-- ensures that the SDF blobs and the green sphere correctly overlap each other.
--
-- We construct sphere lights in the same location as each of the blobs and
-- place these into the scene. These lights affect the SDF surfaces as well as
-- the green sphere.
--
-- I hope you have a good GPU.
--
-- Copyright 2024 by Jonathan Hogg and licensed under CC BY-NC-SA 4.0
--
-- Record a video with:
-- flitter day29.fl --lockstep --runtime=180 --define 'RECORD=1080'

%pragma tempo 60

let SIZE=RECORD or 1080
    NBLOBS=100
    NEUTRAL_DENSITY=1m
    NEUTRAL_TEMPERATURE=1500
    THERMAL_CONDUCTIVITY=0.3m
    LAMP_TEMPERATURE=3000
    THERMAL_GRADIENT=-2000
    THERMAL_CURVE=2
    SMOOTHING=10
    R=80

let t=$(:blob;:clock) or 0
    blob_start_temp=NEUTRAL_TEMPERATURE+100*normal(:radius)[..NBLOBS]
    blob_mass=0.05+uniform(:mass)[..NBLOBS]**3*0.95
    blob_height=$(:blob;i)[1] for i in ..NBLOBS
    lamp_radiant_temperature=LAMP_TEMPERATURE+(1-((R-blob_height)/(R*2))**THERMAL_CURVE)*THERMAL_GRADIENT
    blob_temperature=$(:temperature) or blob_start_temp
    blob_volume=blob_mass/NEUTRAL_DENSITY*blob_temperature/NEUTRAL_TEMPERATURE
    blob_radius=blob_volume**(1/3)
    blob_area=blob_radius**2
    temp=map(0.9, blob_temperature, NEUTRAL_TEMPERATURE)
    rate_of_temperature_change=THERMAL_CONDUCTIVITY*(lamp_radiant_temperature-temp)/blob_mass*blob_area

func blob_color(i)
    colortemp(blob_temperature[i])*300

!counter state=:temperature initial=blob_start_temp time=t rate=rate_of_temperature_change minimum=1 maximum=LAMP_TEMPERATURE

!physics dimensions=3 state=:blob resolution=1/30
    !adhesion strength=2 overlap=0.15
    !buoyancy gravity=0;-100;0 density=NEUTRAL_DENSITY
    !random strength=0.5
    !drag strength=2m
    !anchor id=:middle radius=R/2
    for i in ..NBLOBS
        !particle id=i radius=blob_radius[i] mass=blob_mass[i] position=normal(:pos;i)[..3]*R/5
        !distance from=:middle to=i max=R strength=10

!window size=SIZE
    !canvas3d id=:distance_buffer colorbits=32 hidden=true camera_id=:cam near=1 far=R*3 fov=0.2 fov_ref=:vertical \
              depth_test=false face_cull=false composite=:lighten fragment=read('../glsl/distance_shader.frag')
        !transform rotate_y=beat/30
            !camera id=:cam viewpoint=0;0;R*2
        for i in ..NBLOBS
            !sphere position=$(:blob;i) size=blob_radius[i]+SMOOTHING
    !bloom id=:top radius=hypot(SIZE)/50
        !canvas3d camera_id=:cam near=1 far=R*3 fov=0.2 fov_ref=:vertical fog_curve=2 fog_color=colortemp(NEUTRAL_TEMPERATURE) fog_min=R fog_max=R*3 max_lights=NBLOBS+1
            !transform rotate_y=beat/30
                !camera id=:cam viewpoint=0;0;R*2
            !light color=colortemp(LAMP_TEMPERATURE)*10 direction=0;1;0
            for i in ..NBLOBS
                !light position=$(:blob;i) radius=blob_radius[i] color=2*blob_color(i)*blob_area[i]
            !material color=0;1;0 roughness=0.5
                !sphere size=R/2
            !group fragment=read('../glsl/sdf_sphere_shader.frag') \
                   vertex=read('../glsl/sdf_sphere_shader.vert') \
                   NSPHERES=NBLOBS smoothing=SMOOTHING max_iterations=50 normal_delta=R/100 epsilon=R/100 far=R*3 \
                   sphere_positions=($(:blob;i) for i in ..NBLOBS) \
                   sphere_colors=(blob_color(i) for i in ..NBLOBS) \
                   sphere_radii=blob_radius \
                   distance_buffer=:distance_buffer
                !material roughness=0.4 color=0.5 metal=true
                    for i in ..NBLOBS
                        !sphere position=$(:blob;i) size=blob_radius[i]+SMOOTHING
    !record filename=('day29.mp4' if RECORD and t > 60) codec=:hevc crf=25 hidden=true
        !reference id=:top
