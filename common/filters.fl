
-- Simple bloom filter consisting of a contrast adjustment, gaussian blur and then
-- a 'lighten' composite of the result with the original

func bloom_filter(nodes, radius=0, sigma=0.75, contrast=2, blursize=null, colorbits=null, composite=null, id=null)
    let rx;ry=radius*(1;1)
    !shader#lighten id=id colorbits=colorbits composite=:lighten
        if len(nodes) == 1
            nodes id=:bloom_source composite=composite
        else
            !shader#compose id=:bloom_source composite=composite
                nodes
        !shader#hblur size=blursize horizontal=false radius=ry sigma=sigma fragment=read("../glsl/blur.frag")
            !shader#vblur horizontal=true radius=rx sigma=sigma fragment=read("../glsl/blur.frag")
                !shader#contrast contrast=contrast brightness=(1-contrast)/2 fragment=read("../glsl/color_adjust.frag")
                    !reference id=:bloom_source


-- Simple edge-detection filter that subtracts a gaussian blurred version of the
-- input from the input

func edge_detect(nodes, radius=0, blursize=null, colorbits=null, composite=null, id=null)
    let rx;ry=radius*(1;1)
    !shader#difference id=id colorbits=colorbits composite=:difference
        if len(nodes) == 1
            nodes id=:edge_source composite=composite
        else
            !shader#compose id=:edge_source composite=composite
                nodes
        !shader#hblur size=blursize horizontal=false radius=ry fragment=read("../glsl/blur.frag")
            !shader#vblur horizontal=true radius=rx fragment=read("../glsl/blur.frag")
                !reference id=:edge_source


-- Feedback filter that simulates old-school analogue feedback involving pointing
-- a camera at a telly and mixing this with an input signal. `decay` represents
-- a number of beats over which the old image decays (and is thus mixed back into
-- the next frame); `glow` is an amount of overloading of the input signal into the
-- mixer; `translate`, `scale` and `rotate` represent a transformation of the
-- feedback signal

func feedback_filter(nodes, decay=0, glow=0, translate=0, scale=1, rotate=0, colorbits=null, composite=null, id=null)
    !shader#feedback id=id colorbits=colorbits decay=decay glow=glow translate=translate scale=scale rotate=rotate fragment=read("../glsl/feedback.frag")
        if len(nodes) == 1
            nodes composite=composite
        else
            !shader#compose composite=composite
                nodes
